// Playing 1 bar of sounds generated by the user
playBeat = (soundsArr, partitionArr) => {
  partitionArr.forEach((s, i) => {
    if (s) {
      soundsArr[i].currentTime = 0;
      soundsArr[i].play();
    }
  });
}

// playing the whole partition (loops trough each bar)
playMusic = (soundsArr, partition, tempo) => {
  let counter = 0;
  musicPlaying = setInterval(function () {
    playBeat(soundsArr, partition[counter]);
    highlightCol(counter);
    counter++;
    if (counter === partition.length) {
      counter = 0;
      if (roundIsStarted) giveFeedbackToPlayer();
    }
  }, tempo);
}

// plays the music and replaces by a stop button
playUserMusic = () => {
  playMusic(soundsPlayer, partitionUser, timeoutTempo);
  if (document.contains(document.getElementById('btn-play'))) {
    removeButton('#btn-play');
    createStopButton();
  }
}


// creates a play button
createPlayButton = () => {
  let playButton = document.createElement('button');
  userMusicControls.appendChild(playButton);
  playButton.setAttribute('id', 'btn-play');
  playButton.setAttribute('class', 'btn-control');
  playButton.setAttribute('onclick', 'playUserMusic()');
  playButton.innerText = '> Play';
}

// creates a stop button
createStopButton = () => {
  let stopButton = document.createElement('button');
  userMusicControls.appendChild(stopButton);
  stopButton.setAttribute('id', 'btn-stop');
  stopButton.setAttribute('class', 'btn-control');
  stopButton.setAttribute('onclick', 'stopPlaying()');
  stopButton.innerText = '[] Stop';
}


//remove the button of the passed id
removeButton = (query) => {
  let buttonToRemove = document.querySelector(query);
  userMusicControls.removeChild(buttonToRemove);
}

// creates the listen button
createListenButton = () => {
  let listenButton = document.createElement('button');
  let startOrListenButton = document.getElementById('start-or-listen-button');
  startOrListenButton.appendChild(listenButton);
  listenButton.setAttribute('id', 'listen-button');
  listenButton.setAttribute('class', 'btn-control');
  listenButton.setAttribute('onclick', 'listenToTheDJ(8)');
  listenButton.innerText = '<> Listen Again';
}

// Listen to the example
listenToTheDJ = (measures) => {
  let listenButton = document.getElementById('listen-button');
  document.getElementById('start-or-listen-button').removeChild(listenButton)
  playDJ(soundsDJ, partitionDJ, timeoutTempoDJ, measures);
  setTimeout(function () {
    if (!document.contains(document.getElementById('btn-start-round'))) createListenButton();
  }, timeoutTempoDJ * measures);
}

// computer plays a beat and player has to reproduce, loop stops after 2 times
playDJ = (soundsArr, partition, tempo, measures) => {
  let counter = 0;
  let countTimes = 0;
  djPlaying = setInterval(function () {


    playBeat(soundsArr, partition[counter]);
    counter++;
    countTimes++;
    if (counter === partition.length) counter = 0;
    if (countTimes === measures) clearInterval(djPlaying);
  }, tempo);
}

// highlights the current playing bar
highlightCol = (index) => {
  notesCols.forEach(col => col.classList.remove("notes-col-highlighted"));
  notesCols[index].classList.add("notes-col-highlighted");
}

// updates the tempo when the user changes the value
updateTempoValue = (val) => {
  document.getElementById("tempo-disp").innerText = "Tempo: " + val;
  tempo = val;
  timeoutTempo = 60000 / (tempo * 2);
  clearInterval(musicPlaying);
  playUserMusic();
}

// stops the player music from playing, replaces by a play button
stopPlaying = () => {
  clearInterval(musicPlaying);
  if (document.contains(document.getElementById('btn-stop'))) {
    removeButton('#btn-stop');
    createPlayButton();
  }
}

// checks if the user is reproducing the pattern well and returns the score 
compareMusic = (modelPartition, userPartition) => {
  const modelPartFlat = modelPartition.flat(2);
  const userPartFlat = userPartition.flat(2);
  const compareLength = modelPartFlat.reduce((acc, value) => {
    if (value) acc++
    return acc;
  });

  let compareScore = 0;
  userPartFlat.forEach((note, index) => {
    if (modelPartFlat[index] && note === modelPartFlat[index]) compareScore++;
    if (!modelPartFlat[index] && note && compareScore > 0) compareScore--;
  });
  let score = (compareScore / compareLength) * 100;
  return score;
}

compareTempo = (modelTempo, userTempo) => {
  const difference = Math.abs(userTempo - modelTempo) / modelTempo;
  return difference * 10;
}

giveScore = (modelPartition, userPartition, modelTempo, userTempo) => {
  const tempoDiff = compareTempo(modelTempo, userTempo);
  const musicScore = compareMusic(modelPartition, userPartition);
  const currentScore = (musicScore - tempoDiff).toFixed(0);
  return Math.max(currentScore, 0);
}

// compares what user does with what is needed and returns the
//score in the feedback area

giveFeedbackToPlayer = () => {
  currentScore = giveScore(partitionDJ, partitionUser, timeoutTempoDJ, timeoutTempo);
  const comment = generateComment(currentScore);
  const tempoComment = getTempoComment();
  styleFeedback(currentScore);
  feedbackZone.innerHTML = `${currentScore}% correct <br> ${comment} <br> ${tempoComment}`;
  return currentScore;
}

//styles the comment area depending on the score
styleFeedback = (score) => {
  if (score < 50) {
    feedbackZone.style.fontSize = '20px';
    feedbackZone.style.color = 'black';
  } else if (score < 75) {
    feedbackZone.style.fontSize = '20px';
    feedbackZone.style.color = 'green';
  } else if (score < 100) {
    feedbackZone.style.fontSize = '25px';
    feedbackZone.style.color = 'green';
  } else if (score === 100) {
    feedbackZone.style.fontSize = '28px';
    feedbackZone.style.color = 'green';
  }
}

// generating a comment depending on the current score
generateComment = (score) => {
  let comment = "";
  if (score < 25) {
    comment = "Nothing's going on";
  } else if (score < 50) {
    comment = "Keep trying, padawan";
  } else if (score < 70) {
    comment = "getting closer";
  } else if (score < 85) {
    comment = "Wow, nice!";
  } else if (score < 100) {
    comment = "Almost there!";
  } else {
    comment = "Bravo! That's perfect!";
  }
  return comment;
}

getTempoComment = () => {
  let tempoComment = "";
  if (timeoutTempoDJ < timeoutTempo) tempoComment = "Play faster!";
  else if (timeoutTempoDJ > timeoutTempo) tempoComment = "Play slower!";
  else tempoComment = "tempo ok";
  return tempoComment;
}

// adds the score of the round to the total score of the player
updatePlayerScore = (score, difficulty, remainingTime) => {
  const roundScore = (score * difficulty);
  const timeBonus = Math.round(remainingTime * 10);
  playerScore = playerScore + (roundScore + timeBonus);
  showScoreBoard(roundScore, timeBonus, playerScore, remainingTime);
  document.getElementById('score-span').innerText = `Score: ${playerScore}`;
}

showScoreBoard = (roundSc, timeBo, playerSc, remainingTime) => {
  let scoreBoard = document.getElementById('score-board');
  let boardTitle = document.getElementById('board-title');
  let boardRoundScore = document.getElementById('board-round-score');
  let boardTimeBonus = document.getElementById('board-time-bonus');
  let boardTotalScore = document.getElementById('board-total-score');
  const titleText = (remainingTime) ? "Round Passed!" : "Time's up!";
  boardTitle.innerText = titleText;
  boardRoundScore.innerText = roundSc;
  boardTimeBonus.innerText = timeBo;
  boardTotalScore.innerText = playerSc;
  scoreBoard.style.display = 'flex';
  setTimeout(() => {
    scoreBoard.style.display = 'none';
  }, 4000);
}

// plays one round, is called when player clicks on the button
playRound = () => {
  clearInterval(musicPlaying);
  moveToNextRound();
  clearFeedbackZone();
  roundIsStarted = true;
  let counter = partitionsToPickFrom[roundNb].time;
  let timeSpan = removeStartButton();
  listenToTheDJ(16);
  let roundPlaying = setInterval(function () {
    timeSpan.innerText = `Time: ${counter} sec`;
    counter--;
    if (counter === -1 || currentScore === 100) {
      clearInterval(roundPlaying);
      endCurrentRound(counter + 1);
    }
  }, 1000);
}

// cleans the zone with feedback
clearFeedbackZone = () => {
  styleFeedback(0);
  feedbackZone.innerHTML = "Listen to the beat, and try to re-create it using the pad on the left side!";
}

//resets the player input with all notes to false, resets pad style
clearPartition = () => {
  notes.forEach(noteButton => {
    noteButton.classList.remove("highlighted");
  })
  return partition = [
    [false, false, false, false, false, false],
    [false, false, false, false, false, false],
    [false, false, false, false, false, false],
    [false, false, false, false, false, false]
  ];
}

// removes the start button
removeStartButton = () => {
  let startButton = document.getElementById('btn-start-round');
  let startOrListenButton = document.getElementById('start-or-listen-button');
  let timeSpan = document.getElementById('time-span');
  startOrListenButton.removeChild(startButton);
  createListenButton();
  return timeSpan;
}

// replaces the listen button with the start button after each round
createStartButton = () => {
  let startButton = document.createElement('button');
  startButton.setAttribute('onclick', 'playRound()');
  startButton.setAttribute('class', 'btn-control');
  startButton.setAttribute('id', 'btn-start-round');
  startButton.innerText = 'Start The Round';
  return startButton;
}

// replaces the listen button with the start button after each round
replaceListenWithStart = () => {
  const startButton = createStartButton();
  if (document.contains(document.getElementById('listen-button'))) {
    let listenButton = document.getElementById('listen-button');
    document.getElementById('start-or-listen-button').removeChild(listenButton);
  }
  document.getElementById('start-or-listen-button').appendChild(startButton);
}


// sets up the game for the next round
moveToNextRound = () => {
  currentScore = 0;
  timeoutTempoDJ = 60000 / (partitionsToPickFrom[roundNb].tempo * 2);
  partitionDJ = partitionsToPickFrom[roundNb].notes;
  roundDifficulty = partitionsToPickFrom[roundNb].difficulty;
  updateRoundInfo(roundNb);
}

// ends the current round
endCurrentRound = (remainingTime) => {
  updatePlayerScore(giveFeedbackToPlayer(), roundDifficulty, remainingTime);
  replaceListenWithStart();
  stopPlaying();
  if (remainingTime > 0) soundsAmbiance[0].play();
  else soundsAmbiance[1].play();
  partitionUser = clearPartition();
  roundIsStarted = false;
  roundNb++;
  roundNb = roundNb % partitionsToPickFrom.length;
}

updateRoundInfo = (roundNb) => {
  let roundSpan = document.getElementById('round-span');
  roundSpan.innerHTML = `Round ${roundNb+1} : ${partitionsToPickFrom[roundNb].name}`;
}